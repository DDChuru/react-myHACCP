#!/usr/bin/env node

const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs').promises;
const fsSync = require('fs');
const path = require('path');
const execAsync = promisify(exec);

class AgentWorkflow {
  constructor() {
    this.conversationHistory = [];
    this.taskContext = '';
    this.outputDir = path.join(__dirname, 'agent-outputs');
    this.sessionId = new Date().toISOString().replace(/[:.]/g, '-');
    this.projectRoot = path.resolve(__dirname, '..');
  }

  async ensureOutputDir() {
    try {
      await fs.mkdir(this.outputDir, { recursive: true });
    } catch (error) {
      console.error('Error creating output directory:', error);
    }
  }

  async saveOutput(mode, content, metadata = {}) {
    await this.ensureOutputDir();
    
    const timestamp = new Date().toISOString();
    const filename = `${mode}-${this.sessionId}.md`;
    const filepath = path.join(this.outputDir, filename);
    
    const output = {
      timestamp,
      mode,
      sessionId: this.sessionId,
      metadata,
      content
    };
    
    // Save as Markdown
    const markdownContent = `# Agent-to-Agent Workflow Session
**Date:** ${timestamp}
**Mode:** ${mode}
**Session ID:** ${this.sessionId}

## Metadata
${JSON.stringify(metadata, null, 2)}

## Conversation

${this.formatConversationAsMarkdown(content)}

---
*Generated by agent-workflow.js*
`;
    
    await fs.writeFile(filepath, markdownContent);
    
    // Also save as JSON for programmatic access
    const jsonFilepath = path.join(this.outputDir, `${mode}-${this.sessionId}.json`);
    await fs.writeFile(jsonFilepath, JSON.stringify(output, null, 2));
    
    console.log(`\nüìÅ Output saved to:`);
    console.log(`   Markdown: ${filepath}`);
    console.log(`   JSON: ${jsonFilepath}`);
    
    return filepath;
  }

  formatConversationAsMarkdown(content) {
    if (Array.isArray(content)) {
      return content.map(item => {
        if (item.agent && item.message) {
          return `### ${item.agent}\n${item.message}\n`;
        } else if (item.agent && item.idea) {
          return `### ${item.agent}\n${item.idea}\n`;
        }
        return JSON.stringify(item, null, 2);
      }).join('\n');
    }
    return JSON.stringify(content, null, 2);
  }

  async callGemini(prompt, systemContext = '') {
    try {
      const fullPrompt = systemContext ? `${systemContext}\n\n${prompt}` : prompt;
      const escapedPrompt = fullPrompt.replace(/"/g, '\\"').replace(/\n/g, '\\n');
      
      const { stdout, stderr } = await execAsync(`echo "${escapedPrompt}" | gemini -p "Respond concisely"`);
      
      // Filter out the "Loaded cached credentials" message
      const response = stdout.split('\n')
        .filter(line => !line.includes('Loaded cached credentials'))
        .join('\n')
        .trim();
      
      return response;
    } catch (error) {
      console.error('Error calling Gemini:', error);
      return null;
    }
  }

  async runCollaborativeTask(task) {
    console.log('ü§ñ Starting Agent-to-Agent Workflow');
    console.log('=' .repeat(50));
    console.log(`üìã Task: ${task}\n`);
    
    this.taskContext = task;
    
    // Step 1: Claude (me) initiates with task breakdown
    const claudeInitial = `I'll break down this task: "${task}". Here's my analysis:
    1. Identify key components needed
    2. Suggest implementation approach
    3. Define success criteria`;
    
    console.log('üîµ Claude:', claudeInitial);
    this.conversationHistory.push({ agent: 'Claude', message: claudeInitial });
    
    // Step 2: Get Gemini's perspective
    const geminiResponse1 = await this.callGemini(
      `As a collaborative AI agent, provide your perspective on this task: "${task}". 
      Claude suggested: ${claudeInitial}
      What additional considerations or alternative approaches would you suggest?`
    );
    
    console.log('\nüü¢ Gemini:', geminiResponse1);
    this.conversationHistory.push({ agent: 'Gemini', message: geminiResponse1 });
    
    // Step 3: Claude synthesizes and proposes solution
    const claudeSynthesis = `Based on both perspectives, here's a unified approach:
    - Combine systematic breakdown with alternative considerations
    - Focus on modular implementation
    - Ensure testability and maintainability`;
    
    console.log('\nüîµ Claude:', claudeSynthesis);
    this.conversationHistory.push({ agent: 'Claude', message: claudeSynthesis });
    
    // Step 4: Gemini validates and adds final thoughts
    const geminiValidation = await this.callGemini(
      `Review this unified approach for the task "${task}": ${claudeSynthesis}
      Provide validation, potential risks, and any final optimizations.`
    );
    
    console.log('\nüü¢ Gemini:', geminiValidation);
    this.conversationHistory.push({ agent: 'Gemini', message: geminiValidation });
    
    // Final consensus
    console.log('\n' + '=' .repeat(50));
    console.log('‚úÖ Workflow Complete - Consensus Reached');
    
    // Save the output
    await this.saveOutput('task', this.conversationHistory, { task });
    
    return this.conversationHistory;
  }

  async runCodeReview(code) {
    console.log('üîç Starting Code Review Workflow');
    console.log('=' .repeat(50));
    
    // If code looks like a file path or feature name, try to read actual files
    let actualCode = code;
    let fileContent = '';
    
    if (!code.includes('{') && !code.includes('function') && !code.includes('const')) {
      // This might be a feature name or file path
      console.log('üìÇ Attempting to locate relevant files...');
      
      try {
        // Common paths for features
        const possiblePaths = [
          `app/(drawer)/${code}.tsx`,
          `app/(drawer)/${code}/index.tsx`,
          `services/${code}Service.ts`,
          `components/${code}.tsx`,
          code // if it's already a path
        ];
        
        for (const filePath of possiblePaths) {
          try {
            const fullPath = path.join(this.projectRoot || process.cwd(), filePath);
            if (fsSync.existsSync(fullPath)) {
              fileContent = await fs.readFile(fullPath, 'utf8');
              console.log(`‚úÖ Found file: ${filePath}`);
              actualCode = `File: ${filePath}\n\n${fileContent.substring(0, 2000)}${fileContent.length > 2000 ? '\n... (truncated)' : ''}`;
              break;
            }
          } catch (e) {
            // Continue searching
          }
        }
      } catch (error) {
        console.log('‚ÑπÔ∏è Treating input as code snippet');
      }
    }
    
    // Claude reviews first with more detail
    const claudeReview = `Reviewing code for:
    - Syntax and structure
    - Best practices
    - Performance considerations
    - Security implications
    ${fileContent ? '\n- Architecture and data flow' : ''}`;
    
    console.log('üîµ Claude Review:', claudeReview);
    
    // Provide Gemini with actual code content
    const geminiPrompt = fileContent 
      ? `Review this code from a React Native HACCP application and provide detailed feedback on architecture, implementation quality, potential issues, and improvements:\n\n${actualCode}`
      : `Review this code and provide feedback on quality, potential issues, and improvements:\n${actualCode}`;
    
    const geminiReview = await this.callGemini(geminiPrompt);
    
    console.log('\nüü¢ Gemini Review:', geminiReview);
    
    const reviews = [
      { agent: 'Claude', message: claudeReview },
      { agent: 'Gemini', message: geminiReview }
    ];
    
    // Save the output
    await this.saveOutput('review', reviews, { codeSnippet: code.substring(0, 100) + '...' });
    
    return { claudeReview, geminiReview };
  }

  async brainstorm(topic, rounds = 3) {
    console.log('üí° Starting Brainstorming Session');
    console.log('=' .repeat(50));
    console.log(`Topic: ${topic}\n`);
    
    const ideas = [];
    let previousIdeas = '';
    
    for (let i = 0; i < rounds; i++) {
      console.log(`Round ${i + 1}:`);
      
      // Claude generates ideas
      const claudeIdea = `Idea ${i + 1}: Exploring ${topic} from perspective of scalability and user experience`;
      console.log(`üîµ Claude: ${claudeIdea}`);
      ideas.push({ agent: 'Claude', idea: claudeIdea });
      
      // Gemini builds on it
      const prompt = previousIdeas 
        ? `Building on these ideas about "${topic}": ${previousIdeas}\nClaude just suggested: ${claudeIdea}\nProvide a complementary or alternative idea.`
        : `Brainstorming about "${topic}". Claude suggested: ${claudeIdea}\nProvide your own unique idea.`;
      
      const geminiIdea = await this.callGemini(prompt);
      console.log(`üü¢ Gemini: ${geminiIdea}\n`);
      ideas.push({ agent: 'Gemini', idea: geminiIdea });
      
      previousIdeas += `${claudeIdea} | ${geminiIdea} | `;
    }
    
    // Save the output
    await this.saveOutput('brainstorm', ideas, { topic, rounds });
    
    return ideas;
  }
}

// Example usage
async function main() {
  const workflow = new AgentWorkflow();
  
  // Get command line arguments
  const args = process.argv.slice(2);
  const mode = args[0] || 'task';
  
  switch(mode) {
    case 'task':
      const task = args[1] || 'Create a REST API with authentication';
      await workflow.runCollaborativeTask(task);
      break;
      
    case 'review':
      const code = args[1] || `
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}`;
      await workflow.runCodeReview(code);
      break;
      
    case 'brainstorm':
      const topic = args[1] || 'Improving mobile app offline sync';
      await workflow.brainstorm(topic, 3);
      break;
      
    default:
      console.log('Usage: node agent-workflow.js [mode] [input]');
      console.log('Modes: task, review, brainstorm');
  }
}

if (require.main === module) {
  main().catch(console.error);
}

module.exports = AgentWorkflow;